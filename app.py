import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
import os
import sys

# Agregar rutas locales
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Importar m√≥dulos locales
try:
    from utils.google_sheets import load_data_from_sheets, validate_connection
    from utils.data_analysis import analyze_tipo_comedor
    from config.settings import APP_TITLE
    modules_loaded = True
except ImportError:
    # Fallback si no existen los m√≥dulos (para compatibilidad)
    st.error("‚ö†Ô∏è M√≥dulos locales no encontrados. Usando configuraci√≥n b√°sica.")
    APP_TITLE = "Dashboard Comedores Comunitarios"
    modules_loaded = False

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title=APP_TITLE,
    page_icon="üçΩÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS personalizado
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #2E7D32;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #2E7D32;
    }
    .filter-header {
        color: #1976D2;
        font-weight: bold;
        margin-bottom: 1rem;
    }
    .status-indicator {
        padding: 0.25rem 0.75rem;
        border-radius: 1rem;
        font-size: 0.8rem;
        font-weight: bold;
    }
    .status-connected {
        background-color: #E8F5E8;
        color: #2E7D32;
    }
    .status-error {
        background-color: #FFEBEE;
        color: #C62828;
    }
</style>
""", unsafe_allow_html=True)

def make_headers_unique(headers):
    """Hace √∫nicos los headers duplicados agregando sufijos num√©ricos"""
    unique_headers = []
    header_counts = {}
    
    for header in headers:
        if header in header_counts:
            header_counts[header] += 1
            unique_header = f"{header}_{header_counts[header]}"
        else:
            header_counts[header] = 0
            unique_header = header
        
        unique_headers.append(unique_header)
    
    return unique_headers

# Funci√≥n para cargar datos usando Streamlit Secrets
@st.cache_data(ttl=300)
def load_data_secure():
    """Carga datos usando configuraci√≥n segura desde Streamlit Secrets"""
    try:
        # Verificar si existen los secrets
        if not hasattr(st, 'secrets') or 'gcp_service_account' not in st.secrets:
            st.error("‚ùå Credenciales no configuradas. Configura los secrets en Streamlit Cloud.")
            return None
        
        # Importar dependencias
        import gspread
        from google.oauth2.service_account import Credentials
        
        # Obtener credenciales desde secrets
        credentials_info = dict(st.secrets["gcp_service_account"])
        
        # Definir el scope
        scope = [
            'https://spreadsheets.google.com/feeds',
            'https://www.googleapis.com/auth/drive'
        ]
        
        # Crear credenciales
        credentials = Credentials.from_service_account_info(credentials_info, scopes=scope)
        
        # Autorizar el cliente
        gc = gspread.authorize(credentials)
        
        # Obtener configuraci√≥n de Google Sheets
        sheet_id = st.secrets.get("google_sheets", {}).get("sheet_id", "1fbs-J474JbvV3USg5aQlLUW9sNqkBjcd63qBU1nJeeI")
        worksheet_name = st.secrets.get("google_sheets", {}).get("worksheet_name", "Respuestas de formulario 1")
        
        # Abrir la hoja de c√°lculo
        spreadsheet = gc.open_by_key(sheet_id)
        worksheet = spreadsheet.worksheet(worksheet_name)
        
        # Manejar headers duplicados
        try:
            # Intentar m√©todo est√°ndar primero
            data = worksheet.get_all_records()
            df = pd.DataFrame(data)
        except Exception as e:
            if "header row" in str(e) and ("unique" in str(e) or "duplicates" in str(e)):
                # M√©todo alternativo para headers duplicados
                st.info("üîß Detectados headers duplicados, aplicando correcci√≥n autom√°tica...")
                
                # Obtener datos como lista de listas
                all_values = worksheet.get_all_values()
                
                if not all_values:
                    st.error("‚ùå La hoja de c√°lculo est√° vac√≠a")
                    return None
                
                # Tomar la primera fila como headers y hacer √∫nicos
                headers = all_values[0]
                unique_headers = make_headers_unique(headers)
                
                # Crear DataFrame con headers √∫nicos
                data_rows = all_values[1:]  # Excluir header
                df = pd.DataFrame(data_rows, columns=unique_headers)
                
                st.success(f"‚úÖ Headers duplicados corregidos autom√°ticamente")
            else:
                raise e
        
        if df.empty:
            st.warning("‚ö†Ô∏è La hoja de c√°lculo no contiene datos")
            return None
        
        # Limpiar datos b√°sicos
        df = clean_dataframe(df)
        
        return df
        
    except gspread.SpreadsheetNotFound:
        st.error("‚ùå Hoja de c√°lculo no encontrada. Verifica el sheet_id en los secrets.")
        return None
    except gspread.WorksheetNotFound:
        st.error("‚ùå Hoja de trabajo no encontrada. Verifica el worksheet_name en los secrets.")
        return None
    except Exception as e:
        st.error(f"‚ùå Error al cargar datos: {str(e)}")
        return None

def clean_dataframe(df):
    """Limpia y prepara el DataFrame"""
    try:
        # Eliminar filas completamente vac√≠as
        df = df.dropna(how='all')
        
        # Convertir columnas num√©ricas donde sea posible
        numeric_columns = ['COMUNA', 'NODO ', 'NICHO ', 'A√ëO DE VINCULACI√ìN AL PROGRAMA']
        for col in numeric_columns:
            if col in df.columns:
                try:
                    df[col] = pd.to_numeric(df[col], errors='ignore')
                except:
                    pass
        
        # Limpiar espacios en blanco en columnas de texto
        text_columns = df.select_dtypes(include=['object']).columns
        for col in text_columns:
            try:
                df[col] = df[col].astype(str).str.strip()
                # Reemplazar cadenas vac√≠as con NaN
                df[col] = df[col].replace(['', 'nan', 'None'], None)
            except:
                pass
        
        return df
        
    except Exception as e:
        st.error(f"Error limpiando datos: {e}")
        return df

def analyze_tipo_comedor_fallback(df):
    """Analiza la distribuci√≥n de tipos de comedores (funci√≥n de respaldo)"""
    if df is None or df.empty:
        return None, None
    
    # Buscar columna de tipo de comedor de forma flexible
    tipo_col = None
    for col in df.columns:
        if 'tipo' in col.lower() and 'comedor' in col.lower():
            tipo_col = col
            break
    
    if not tipo_col:
        return None, "‚ùå No se encontr√≥ columna de 'TIPO DE COMEDOR'"
    
    # Contar valores en la columna encontrada
    tipo_counts = df[tipo_col].dropna().value_counts()
    
    if tipo_counts.empty:
        return None, "‚ö†Ô∏è No hay datos v√°lidos en la columna de tipos"
    
    # Calcular porcentajes
    tipo_percentages = (tipo_counts / len(df.dropna(subset=[tipo_col]))) * 100
    
    # Crear an√°lisis textual
    total_comedores = len(df.dropna(subset=[tipo_col]))
    tipos_disponibles = list(tipo_counts.index)
    
    analysis_text = f"""
    ## üìä An√°lisis de Tipos de Comedores
    
    **Resumen General:**
    - **Total de comedores registrados:** {total_comedores:,}
    - **Tipos identificados:** {len(tipos_disponibles)}
    - **Columna utilizada:** {tipo_col}
    
    **Distribuci√≥n por tipo:**
    """
    
    for tipo, count in tipo_counts.items():
        percentage = (count / total_comedores) * 100
        analysis_text += f"\n- **{tipo}:** {count:,} comedores ({percentage:.1f}%)"
    
    # Agregar insights adicionales
    if len(tipo_counts) > 0:
        tipo_mas_comun = tipo_counts.index[0]
        analysis_text += f"""
        
        **Insights clave:**
        - El tipo m√°s com√∫n es: **{tipo_mas_comun}**
        - Representa el {tipo_percentages.iloc[0]:.1f}% del total de comedores
        """
        
        if len(tipo_counts) > 1:
            segundo_tipo = tipo_counts.index[1]
            analysis_text += f"\n- El segundo tipo m√°s com√∫n es: **{segundo_tipo}** ({tipo_percentages.iloc[1]:.1f}%)"
    
    return tipo_counts, analysis_text

def show_connection_status():
    """Muestra el estado de la conexi√≥n"""
    if hasattr(st, 'secrets') and 'gcp_service_account' in st.secrets:
        st.success("‚úÖ Credenciales configuradas correctamente")
    else:
        st.warning("‚ö†Ô∏è Credenciales no configuradas. Configura los secrets para conectar con Google Sheets.")

def find_column_flexible(df, search_terms):
    """Busca una columna de forma flexible"""
    for term in search_terms:
        # B√∫squeda exacta
        if term in df.columns:
            return term
        # B√∫squeda parcial
        for col in df.columns:
            if term.lower() in col.lower():
                return col
    return None

def create_filters_sidebar(df):
    """Crea los filtros en el sidebar"""
    st.sidebar.markdown('<div class="filter-header">üîç Filtros de B√∫squeda</div>', unsafe_allow_html=True)
    
    # Crear copia para filtros
    df_filtered = df.copy()
    
    # Definir columnas a buscar
    filter_configs = [
        (['NOMBRE DEL COMEDOR', 'NOMBRE', 'COMEDOR'], 'üìç Nombre del Comedor:', 'Todos'),
        (['BARRIO'], 'üèòÔ∏è Barrio:', 'Todos'),
        (['COMUNA'], 'üèõÔ∏è Comuna:', 'Todas'),
        (['NODO ', 'NODO'], 'üîó Nodo:', 'Todos'),
        (['NICHO ', 'NICHO'], 'üéØ Nicho:', 'Todos')
    ]
    
    applied_filters = 0
    
    for search_terms, label, default_option in filter_configs:
        found_col = find_column_flexible(df, search_terms)
        
        if found_col:
            unique_values = [default_option] + sorted([
                str(x) for x in df_filtered[found_col].dropna().unique() 
                if str(x) not in ['nan', 'None', '']
            ])
            
            if len(unique_values) > 1:
                selected = st.sidebar.selectbox(label, unique_values, key=f"filter_{found_col}")
                
                if selected != default_option:
                    df_filtered = df_filtered[df_filtered[found_col].astype(str) == selected]
                    applied_filters += 1
    
    # Mostrar informaci√≥n de filtros aplicados
    st.sidebar.markdown("---")
    st.sidebar.markdown(f"**Registros mostrados:** {len(df_filtered):,} de {len(df):,}")
    
    if applied_filters > 0:
        st.sidebar.markdown(f"**Filtros activos:** {applied_filters}")
    
    # Bot√≥n para limpiar filtros
    if st.sidebar.button("üîÑ Limpiar Filtros"):
        st.rerun()
    
    return df_filtered

def show_metrics(df_filtered, df_original):
    """Muestra las m√©tricas principales"""
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown("""
        <div class="metric-card">
            <h4>Total Comedores</h4>
            <h2 style="color: #2E7D32;">{:,}</h2>
        </div>
        """.format(len(df_filtered)), unsafe_allow_html=True)
    
    with col2:
        # Buscar columna de tipos din√°micamente
        tipo_col = find_column_flexible(df_filtered, ['TIPO DE COMEDOR', 'TIPO', 'COMEDOR'])
        
        if tipo_col:
            tipos_activos = len(df_filtered[tipo_col].dropna().unique())
        else:
            tipos_activos = 0
            
        st.markdown("""
        <div class="metric-card">
            <h4>Tipos de Comedores</h4>
            <h2 style="color: #1976D2;">{}</h2>
        </div>
        """.format(tipos_activos), unsafe_allow_html=True)
    
    with col3:
        # Buscar columna de barrios din√°micamente
        barrio_col = find_column_flexible(df_filtered, ['BARRIO'])
        
        if barrio_col:
            barrios_activos = len(df_filtered[barrio_col].dropna().unique())
        else:
            barrios_activos = 0
            
        st.markdown("""
        <div class="metric-card">
            <h4>Barrios Cubiertos</h4>
            <h2 style="color: #F57C00;">{}</h2>
        </div>
        """.format(barrios_activos), unsafe_allow_html=True)
    
    with col4:
        # Buscar columna de comunas din√°micamente
        comuna_col = find_column_flexible(df_filtered, ['COMUNA'])
        
        if comuna_col:
            comunas_activas = len(df_filtered[comuna_col].dropna().unique())
        else:
            comunas_activas = 0
            
        st.markdown("""
        <div class="metric-card">
            <h4>Comunas Activas</h4>
            <h2 style="color: #7B1FA2;">{}</h2>
        </div>
        """.format(comunas_activas), unsafe_allow_html=True)

def show_data_info(df):
    """Muestra informaci√≥n sobre los datos cargados"""
    st.markdown("## üìã Informaci√≥n del Dataset")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown(f"""
        **üìä Resumen de Datos:**
        - **Filas:** {len(df):,}
        - **Columnas:** {len(df.columns)}
        - **Memoria:** {df.memory_usage(deep=True).sum() / 1024:.1f} KB
        """)
    
    with col2:
        st.markdown(f"""
        **üïí Informaci√≥n Temporal:**
        - **Cargado:** {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
        - **Fuente:** Google Sheets
        """)

# Funci√≥n principal
def main():
    # T√≠tulo principal
    st.markdown('<h1 class="main-header">üçΩÔ∏è Dashboard Comedores Comunitarios</h1>', unsafe_allow_html=True)
    
    # Mostrar estado de conexi√≥n
    show_connection_status()
    
    # Cargar datos
    with st.spinner('Cargando datos desde Google Sheets...'):
        df = load_data_secure()
    
    if df is None:
        st.error("‚ùå No se pudieron cargar los datos.")
        st.info("""
        ### üîß Pasos para solucionar:
        
        1. **Verifica los secrets** en Streamlit Cloud
        2. **Confirma el ID de Google Sheets** y nombre de la hoja
        3. **Aseg√∫rate de que la cuenta de servicio** tenga acceso a la hoja
        4. **Revisa los logs** para errores espec√≠ficos
        """)
        return
    
    # Informaci√≥n b√°sica de los datos
    st.success(f"üìä **Datos cargados exitosamente:** {len(df):,} registros encontrados")
    
    # Mostrar informaci√≥n del dataset
    show_data_info(df)
    
    # Crear filtros en sidebar
    df_filtered = create_filters_sidebar(df)
    
    # Mostrar m√©tricas principales
    show_metrics(df_filtered, df)
    
    st.markdown("---")
    
    # Informaci√≥n sobre filtros aplicados
    if len(df_filtered) != len(df):
        st.markdown("## üîç Filtros Aplicados")
        st.info(f"""
        **Datos filtrados:** Se est√°n mostrando {len(df_filtered):,} de {len(df):,} registros totales.
        
        Los filtros aplicados afectan todas las visualizaciones y an√°lisis en las p√°ginas del dashboard.
        """)
    
    # Secci√≥n de vista r√°pida de datos
    st.markdown("## üëÄ Vista R√°pida de Datos")
    
    if not df_filtered.empty:
        # Mostrar las primeras 5 columnas por defecto
        default_columns = df_filtered.columns[:min(6, len(df_filtered.columns))].tolist()
        
        selected_columns = st.multiselect(
            "Selecciona las columnas a mostrar:",
            options=df_filtered.columns.tolist(),
            default=default_columns,
            help="Selecciona qu√© informaci√≥n quieres ver en la tabla"
        )
        
        if selected_columns:
            # Mostrar datos filtrados
            st.dataframe(
                df_filtered[selected_columns],
                use_container_width=True,
                height=400
            )
            
            # Opci√≥n para descargar datos
            st.markdown("### üì• Descargar Datos")
            csv = df_filtered[selected_columns].to_csv(index=False)
            st.download_button(
                label="üì• Descargar datos filtrados (CSV)",
                data=csv,
                file_name=f"comedores_filtrados_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                mime='text/csv',
                help="Descarga los datos actuales con los filtros aplicados"
            )
        else:
            st.info("üëÜ Selecciona al menos una columna para mostrar los datos.")
    else:
        st.warning("No hay datos para mostrar con los filtros aplicados.")
    
    # Footer
    st.markdown("---")
    st.markdown("""
    <div style='text-align: center; color: #666; padding: 20px; background-color: #f8f9fa; border-radius: 10px;'>
        üìä <strong>Dashboard de Comedores Comunitarios</strong><br>
        Desarrollado para el an√°lisis integral de datos de comedores comunitarios<br>
        üí° <em>Usa el men√∫ lateral para navegar entre las diferentes secciones de an√°lisis</em>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()